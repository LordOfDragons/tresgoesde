/* 
 * Trespasser Goes Drag[en]gine
 *
 * Copyright (C) 2020, Roland PlÃ¼ss (roland@rptd.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

namespace TresGoesDE.Converting


pin Dragengine.Preloading
pin Dragengine.Scenery
pin Dragengine.XML


/**
 * Instance to export.
 */
class ExportInstance
	private var GroffInstance pGroffInstance
	
	private var bool pIsPhysics
	private var bool pIsTrigger
	private var bool pIsModel
	private var bool pIsOcclusion
	private var bool pIsVisible
	private var String pTpClass
	
	private var String pClass
	private var StubWithProperties pProperties
	private var GroffModel pModel
	private var GroffModel pPhysics
	private var GroffModel pOcclusion
	
	private var GroffInstance pZeroInstance
	private var Array pPhysicsInstances
	
	
	public func new( GroffInstance groffInstance )
		pGroffInstance = groffInstance
		pTpClass = ""
		pClass = ""
		pProperties = StubWithProperties.new()
		pIsVisible = true
		pPhysicsInstances = Array.new()
	end
	
	
	public func GroffInstance getGroffInstance()
		return pGroffInstance
	end
	
	
	public func bool getIsPhysics()
		return pIsPhysics
	end
	
	public func bool getIsTrigger()
		return pIsTrigger
	end
	
	public func bool getIsModel()
		return pIsModel
	end
	
	public func bool getIsOcclusion()
		return pIsOcclusion
	end
	
	public func bool getIsVisible()
		return pIsVisible
	end
	
	public func String getTpClass()
		return pTpClass
	end
	
	
	public func String getClass()
		return pClass
	end
	
	public func StubWithProperties getProperties()
		return pProperties
	end
	
	public func GroffModel getModel()
		return pModel
	end
	
	public func GroffModel getPhysics()
		return pPhysics
	end
	
	public func GroffModel getOcclusion()
		return pOcclusion
	end
	
	
	public func void prepare( Groff groff, GroffValueName propertyClass, GroffValueName propertyVisible )
		identify( groff, propertyClass, propertyVisible )
		processProperties( groff )
		findZeroInstance( groff )
		findPhysicsInstances( groff )
	end
	
	public func void findZeroInstance( Groff groff )
		var String name = pGroffInstance.getName().getName()
		var String suffix = name.substring( -3 )
		if suffix.getAt( 0 ) == '-' and not suffix.equals( "-00" )
			pZeroInstance = groff.getInstanceByName( name.substring( 0, -3 ) + "-00" )
		end
	end
	
	private func void findPhysicsInstances( Groff groff )
		if pZeroInstance != null or not pProperties.getPropertyValueFor( "Type", "Box" ).equals( "Compound" )
			return
		end
		
		var Array keys = pProperties.getPropertyKeys()
		keys.forEach( block String key
			if key.getLength() == 7 and key.substring( 0, 5 ).equals( "Model" )
				pPhysicsInstances.add( groff.getInstanceByName( pProperties.getPropertyValueFor( key, null ) ) )
			end
		end )
	end
	
	class ExportRigBuilder extends RigBuilder
		public var ShapeList shapes
		public var Array properties
		
		public func new()
			shapes = ShapeList.new()
			properties = Array.new()
		end
		
		protected func void buildRig()
			setCentralMassPoint( Vector.new() )
			setModelCollision( false )
			setShapes( shapes )
			setShapeProperties( properties )
		end
	end
	
	// Call this only on "-00" instances
	private func void exportRig( Exporter exporter, String filename )
		var ExportRigBuilder builder = ExportRigBuilder.new()
		var Vector minExtend, maxExtend, rotation
		var DMatrix matrix, invMatrix
		var GroffGeometry geometry
		var DVector position
		var float scale
		
		if pPhysicsInstances.getCount() > 0
			position = Exporter.transformPosition( pGroffInstance.getPosition() )
			rotation = Exporter.transformRotation( pGroffInstance.getRotation() )
			scale = pGroffInstance.getScale()
			
			invMatrix = DMatrix.newSRT( DVector.new( scale, scale, scale ), \
				DVector.new( rotation ), position ).getInverse()
			
			pPhysicsInstances.forEach( block GroffInstance each
				position = Exporter.transformPosition( each.getPosition() )
				rotation = Exporter.transformRotation( each.getRotation() )
				scale = each.getScale()
				
				matrix = DMatrix.newSRT( DVector.new( scale, scale, scale ), \
					DVector.new( rotation ), position ) * invMatrix
				
				geometry = each.getModel().getGeometry()
				minExtend = Exporter.transformPosition( geometry.getBoundingBoxMin() )
				maxExtend = Exporter.transformPosition( geometry.getBoundingBoxMax() )
				builder.shapes.addBox( ( matrix * DVector.new( ( minExtend + maxExtend ) * 0.5 ) ).toVector(), \
					( maxExtend - minExtend ) * ( 0.5 * matrix.getViewVector().getLength() ), \
					matrix.normalize().toQuaternion() )
				builder.properties.add( "" )
			end )
			
		else
			geometry = pModel.getGeometry()
			scale = pGroffInstance.getScale() * 0.5
			minExtend = geometry.getBoundingBoxMin()
			maxExtend = geometry.getBoundingBoxMax()
			builder.shapes.addBox( ( minExtend + maxExtend ) * scale, ( maxExtend - minExtend ) * scale )
			builder.properties.add( "" )
		end
		
		builder.build( "" ).save( filename )
	end
	
	public func void export( Exporter exporter, ExportWorld world )
		if pClass.equals( "TerrainPlacement" )
			return
		end
		
		var EasyXMLElement tag, tagObject = world.getTagWorld().addTag( "object" )
		tagObject.setAttribute( "id", world.nextObjectID().toHexString() )
		
		var DVector position = Exporter.transformPosition( pGroffInstance.getPosition() )
		var Vector rotation = Exporter.transformRotation( pGroffInstance.getRotation() )
		var float scale = pGroffInstance.getScale()
		if pModel != null and pModel.getBaseScale() != null
			scale /= pModel.getBaseScale().value()
		end
		
		tagObject.addDataTag( "classname", pClass )
		
		tag = tagObject.addTag( "position" )
		tag.setAttribute( "x", position.getX() )
		tag.setAttribute( "y", position.getY() )
		tag.setAttribute( "z", position.getZ() )
		
		tag = tagObject.addTag( "rotation" )
		tag.setAttribute( "x", rotation.getX() )
		tag.setAttribute( "y", rotation.getY() )
		tag.setAttribute( "z", rotation.getZ() )
		
		tag = tagObject.addTag( "scaling" )
		tag.setAttribute( "x", scale )
		tag.setAttribute( "y", scale )
		tag.setAttribute( "z", scale )
		
		tag = tagObject.addDataTag( "property", pGroffInstance.getName().getName() )
		tag.setAttribute( "key", "tresId" )
		
		if pModel != null
			tag = tagObject.addDataTag( "property", \
				( exporter.getPathModelDir() + ( pModel.getName().getName() + ".demodel" ) ).getPath() )
			tag.setAttribute( "key", "component.model" )
			exporter.addModel( pModel )
			
			if pModel.getMapping() != null and pModel.getMapping().getMaterial() != null
				tag = tagObject.addDataTag( "property", \
					( exporter.getPathSkinDir() + ( pModel.getName().getName() + ".deskin" ) ).getPath() )
				tag.setAttribute( "key", "component.skin" )
				exporter.addSkin( pModel )
			end
			
			var String rigFilename = ( exporter.getPathRigDir() + ( pModel.getName().getName() + ".derig" ) ).getPath()
			
			if pZeroInstance == null
				exportRig( exporter, rigFilename )
			end
			
			tag = tagObject.addDataTag( "property", rigFilename )
			tag.setAttribute( "key", "component.rig" )
		end
		
		if pOcclusion != null
			tag = tagObject.addDataTag( "property", \
				( exporter.getPathOcclusionMeshDir() + ( pOcclusion.getName().getName() + ".deoccmesh" ) ).getPath() )
			tag.setAttribute( "key", "component.occlusionMesh" )
			exporter.addOcclusionMesh( pOcclusion )
		end
		
		if pModel != null and pModel.getGeometry() != null
			var GroffGeometry geometry = pModel.getGeometry()
			
			var DVector bbmin = Exporter.transformPosition( DVector.new( geometry.getBoundingBoxMin() ) )
			tag = tagObject.addDataTag( "property", "" + bbmin.getX() + " " + bbmin.getY() + " " + bbmin.getZ() )
			tag.setAttribute( "key", "boundingBoxMin" )
			
			var DVector bbmax = Exporter.transformPosition( DVector.new( geometry.getBoundingBoxMax() ) )
			tag = tagObject.addDataTag( "property", "" + bbmax.getX() + " " + bbmax.getY() + " " + bbmax.getZ() )
			tag.setAttribute( "key", "boundingBoxMax" )
		end
		
		pProperties.getPropertyKeys().forEach( block String key
			tag = tagObject.addDataTag( "property", pProperties.getPropertyValueFor( key, null ) )
			tag.setAttribute( "key", key )
		end )
	end
	
	
	private func void addProperties( Groff groff, GroffValue table, String prefix )
		table.forEachProperty( block GroffValue data
			var String name = data.getName().getName()
			if name.equals( "Class" ) or name.equals( "Diffuse" ) // "SubMaterial{:2d}"
				return null
			end
			
			select data.getType()
			case GroffValue.Type.boolean
				pProperties.setPropertyBoolFor( prefix + name, data.getDataBool() )
				
			case GroffValue.Type.character
				pProperties.setPropertyValueFor( prefix + name, data.getDataByte().toString() )
				
			case GroffValue.Type.integer
				pProperties.setPropertyIntFor( prefix + name, data.getDataInt() )
				
			case GroffValue.Type.floating
				pProperties.setPropertyFloatFor( prefix + name, data.getDataFloat() )
				
			case GroffValue.Type.string
				var String string = data.getDataString()
				if string.substring( -4 ).toLower().equals( ".bmp" )
					string = string.substring( 0, -4 ) + ".png"
				end
				pProperties.setPropertyValueFor( prefix + name, string )
				
			case GroffValue.Type.group
				addProperties( groff, data, prefix + name )
			end
		end )
	end
	
	private func void identify( Groff groff, GroffValueName propertyClass, GroffValueName propertyVisible )
		var GroffModel model = pGroffInstance.getModel()
		if model != null and model.getBaseScale() != null
			model.setBaseScale( Float.new( pGroffInstance.getScale() ) )
		end
		
		var GroffValue valueTable = pGroffInstance.getValueTable()
		if valueTable.getType() == GroffValue.Type.group
			var GroffValue property = valueTable.getProperty( propertyClass )
			if property != null
				pTpClass = property.getDataString()
				pIsTrigger = getTriggerClasses().has( pTpClass )
				pIsModel = getModelClasses().has( pTpClass )
			end
			
			property = valueTable.getProperty( propertyVisible )
			if property != null
				pIsVisible = property.getDataBool()
			end
		end
		
		pIsPhysics = pGroffInstance.getName().getName().getAt( 0 ) == '$'
		if pIsPhysics
			return
		end
		
		if pTpClass.empty()
			pTpClass = "CInstance"
		end
		
		pClass = pTpClass
		pModel = pGroffInstance.getModel()
		
		if valueTable.getType() == GroffValue.Type.group
			addProperties( groff, valueTable, "" )
		end
		
		if model != null and model.getMapping() != null and model.getMapping().getMaterial() != null
			var bool hasNonOccMat = model.getMapping().getMaterial().findPid( block PidFileEntry pid
				return pid != null and not pid.getOcclusion()
			end ) != null
			
			var bool hasOccMat = model.getMapping().getMaterial().findPid( block PidFileEntry pid
				return pid != null and pid.getOcclusion()
			end ) != null
			
			if hasOccMat and not hasNonOccMat
				pClass = "Occlusion"
				pOcclusion = pModel
				pModel = null
				pIsOcclusion = true
			end
		end
	end
	
	private func void processProperties( Groff groff )
	end
	
	
	static private var Array pTriggerClasses = null
	static private var Array pModelClasses = null
	
	static private func Array getTriggerClasses()
		if pTriggerClasses == null
			pTriggerClasses = Array.new()
			pTriggerClasses.add( "CBooleanTrigger" )
			pTriggerClasses.add( "CCollisionTrigger" )
			pTriggerClasses.add( "CCreatureTrigger" )
			pTriggerClasses.add( "CLocationTrigger" )
			pTriggerClasses.add( "CMoreMassTrigger" )
			pTriggerClasses.add( "CObjectTrigger" )
			pTriggerClasses.add( "CSequenceTrigger" )
			pTriggerClasses.add( "CStartTrigger" )
			pTriggerClasses.add( "CTimerTrigger" )
			pTriggerClasses.add( "CVariableTrigger" )
		end
		return pTriggerClasses
	end
	
	static private func Array getModelClasses()
		if pModelClasses == null
			pModelClasses = Array.new()
			pModelClasses.add( "CAnimal" )
			pModelClasses.add( "CEntityAttached" )
			pModelClasses.add( "CEntityWater" )
			pModelClasses.add( "CGun" )
			pModelClasses.add( "CInstance" )
			pModelClasses.add( "CMuzzleFlash" )
			pModelClasses.add( "Player" )
		end
		return pModelClasses
	end
end
